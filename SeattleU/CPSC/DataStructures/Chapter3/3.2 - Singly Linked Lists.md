### 1) Define `Node` Class

``` C++
template <typename E>
class Node { // singly linked list node
private:
	E elem; // linked list element value
	Node<E>* next; // next item in the list
	friend class LinkedList<E>; // provide SLinkedList access
}
```

### 2) Define `LinkedList` Class

``` C++
class LinkedList { // A singly linked list
public:
	LinkedList(); // empty list constructor
	~LinkedList(); // destructor
	bool empty() const; // is list empty?
	const E& front() const; // get front element
	void addFront (const E& e); // add to front of list
	void removeFront(); // remove front item list
private:
	Node<E>* head; // pointer to head of list
};

template <typename E>
LinkedList<E>::LinkedList()  // constructor
	: head (NULL) { }
	
template <typename E>
LinkedList<E>::~LinkedList()  // deconstructor
	{ while (!empty()) removeFront(); }
	
template <typename E>
bool LinkedList<E>::empty() const // is list empty?
	{ return head == NULL; }
	
const E& LinkedList::front() const // return front element
	{ return head->elem; }
	
template <typename E>
void LinkedList<E>::addFront(const string& e) { // add to front of list
	Node* v = new StringNode; // create new node
	v->elem = e; // store data
	v->next = head; // head now follows v
	head = v; // v is now the head
}

template <typename E>
void LinkedList<E>::removeFront() { // remove front item
	Node* old = head;
	head = old->next;
	delete old;
}
```

### 3) Implementation

``` C++
LinkedList<int> nums;
nums.addFront(1);
// ...
nums.addFront(26);
// [front]26->25->...->2->1[back]
nums.removeFront(); //removes 26 from linked list
```