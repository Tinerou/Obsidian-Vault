#DataStructures 
### Memory Instructions

#### lw
The load word `lw` instruction obtains a word from memory and places into a register:

`lw`$R_DR_AImm6$       $R(R_D)$←$M[R(R_A)+Imm6]$

- $R_D$ is the destination register that receives the word from memory
- $R_A$ and $Imm6$ are used to compute the address of the word in memory that will be read
#### sw
The store word `sw` instruction writes a word to memory writes a word to memory, 
pretty much `lw` but the other way around:

`sw`$R_DR_AImm6$       $M[(R_A)+Imm6]$←$R(R_D)$

- $R_D$ is the register that contains the data to store.
- $R_A$ and the $Imm6$ are used to compute the effective address (same computation as a load)
#### Memory addresses
- The *effective address* is computed by adding the contents of $R_A$ with the immediate
- Addresses in ANNA are unsigned. The value of register $R_A$ is treated as an unsigned number
	- The immediate is signed and represents an offset from the address
	- If the resulting addition results in a negative address, the ANNA simulator will wraparound to a larger unsigned address
- ANNA is a *load/store architecture*. Only `lw` and `sw` instructions are allowed to access memory directly.
#### Fetch and Execute Loop Memory Instructions
1) Fetch the instruction at the offset in memory indicated by the PC
2) Set PC ← PC + 1
3) Compute the effective address
4) (`sw` only): Get the value of the data register.
5) Access memory using effective address
	- `lw` reads from memory
	- `sw` writes to memory
6) (`lw` only): Place the result into the destination register

### Variables in Assembly Language

- Variables are often stored in memory as there are not enough registers to store all variables
- However, variables must be placed in registers before they can be used in operations. A typical, but slow, method:
	1) Place the addresses of the desired variables into registers
	2) Load the operands into registers
	3) Perform the desired operation
	4) Store the result into memory
- If a variable is used frequently, it is better to keep in a register for performance purposes. Register allocation is a key responsibility carried out by the compiler

#### Example

![[Pasted image 20251022114257.png]]

#### .fill
The `.fill` assembler directive tells the assembler to fill in the next word in memory with the entire 16-bit immediate value:

`.fill` $Imm16$

- $Imm16$ is a signed 16-bit immediate
- Immediate can be either a signed immediate or a four digit hexadecimal number

#### Initializing Variables
The `.fill` directive is used to initialize variables:
- A label is used to identify the variable (often the same name as the variable).
- `.fill` is used to initialize the value of the variable
##### Example
Translate the variable declaration: `int count = 5` into ANNA assembly:
`count: .fill 5`

#### Using Labels for Addresses
Once labels are used to declare variables, they can be used in `lui` and `lli` instructions
- The immediate corresponds to the *address* of the word defined by the label
##### Example
Assume `count` is at address `0x5678`:
`lli r4 &count` is identical to `lli r4 0x78`
`lui r4 &count` is identical to `lui r4 0x56`

Note: Useful so programmers do not have to keep track of the addresses of the variables they declare

#### Memory Sections
For assembly programs that require memory beyond registers, it is useful to divide the assembly program into a code section and data section

Real programs, from a memory perspective, consists of 4 sections:
- *Code:* Machine code instructions
- *Data:* Global variables/constants used by the program
- *Stack:* Stores activation records (which store parameters and local variables)
- *Heap:* Memory dynamically allocated by the program

##### Example 1
Write code that initializes `x` to `25`, then executes `y = x + 2`:
```Assembly
# code section
lli r1 &x
lui r1 &x        # r1 = &x
lli r2 &y
lui r2 &y        # r2 = &y
lw r3 r1 0       # r3 = x
addi r4 r3 2     # r4 = x+2
sw r4 r2 0       # y = x+2
.halt

# data section
x: .fill 25
y: .fill 0
```

![[Pasted image 20251022120820.png]]

##### Example 2
Convert to ANNA assembly code:
```C++
x = 5;
y = 52;
x = x + (y >> 2);
```

```Assembly
# code section
lli r1 &x
lui r1 &x
lli r2 &y
lui r2 &y
lw r3 r1 0
lw r4 r2 0
shf r5 r4 -2
addi r6 r3 r5
sw r6 r1 0
.halt

# data section
x: .fill 5
y: .fill 52
```

### Pointers

**Pointers store addresses of other variables**
- We've already seen registers hold addresses

##### Example 1 
Convert `p = &x;` into ANNA assembly. Assume that `x` (type: `int`) and `p` (type: `int *`) are declared using labels in the data section
``` Assembly
lli r1 &x
lui r1 &x
lli r2 &p
lui r2 &p
sw r1 r2 
```

##### Example 2
Convert `*p = 3;` into ANNA assembly
```Assembly
lli r1 &p
lui r1 &p
lw r2 r1 0
lli r3 3
sw r3 r2
```

##### Example 3
Convert `cout << *p << endl;` into ANNA assembly
```Assembly
lli r1 &p
lui r1 &p      # r1 = &p
lw r2 r1 0     # r2 = p
lw r3 r2 0     # r3 = *p
out r3
```

##### In class Examples 1-3
![[Pasted image 20251022124709.png]]

### Arrays
Arrays are sequentially laid out in memory:
- Let element 0 have address $n$
- Then, address of element $i$: $n+(i*sizeof(element))$
- $sizeof(element)$ is in terms of number of words
- In ANNA, integers are 1 word. So, $sizeof(element) = 1$ 
	- → Address of element $i = n+ 1$
![[Pasted image 20251022125147.png]]

##### Examples
Convert `int list[5];` into ANNA assembly
```Assembly
list:.fill 0   # list[0]
	.fill 0    # list[1]
	.fill 0    # list[2]
	.fill 0    # list[3]
	.fill 0    # list[4]
```
Convert `list[3] = 10;` into ANNA assembly
```Assembly
lli r1 &list   # store the base of list into r1
lui r1 &list   # r1 = &list[0]
lli r2 10 
sw r2 r1 3     # list[3] = 10 # 3 is the offset
```
Convert `y = list[x];` into ANNA assembly. Assume that `x` is in `r3` and `y` is in `r4`
```Assembly
lli r1 &list
lui r1 &list    # r1 = &list[0], p = &list[0]
add r1 r1 r3    # r1 = &list[x], p = p+x
lw r4 r1 0      # y = &list[x], y = *p
```