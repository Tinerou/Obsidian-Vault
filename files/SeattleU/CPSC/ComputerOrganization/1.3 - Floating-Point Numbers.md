#ComputerOrganization 

## Floating-Point Number Representation

### Floating-Point Numbers

To represent non-integral numbers, computers use *floating-point numbers*.
- In base-10, such numbers have *decimal point*
- Since computers represent everything in binary, we call it a *binary point*
- However, the more generic term *floating point* is more commonly used

Computers use a form of scientific notation for floating-point representation
- Numbers written in scientific notation have 3 components:
	1) sign
	2) significand
	3) exponent
![[Pasted image 20251006110501.png]]

### IEEE Floating-Point Representation

![[Pasted image 20251006110613.png]]
- The one-bit *sign* field is the sign of the stored value
	- 0 is positive, 1 is negative
- The size of the *exponent* determines the range of values that can be represented
- The size of the *fraction* determines the precision of the representation

## Converting Decimal to Floating-Point

### Steps for conversion

1) Convert the decimal number into a binary number
2) Express the floating-point number in scientific notation
3) Fill in the various fields of the floating-point number appropriately

**Step 1:** Convert the decimal number into a binary number

Just like a base-10 number with a decimal point, the bits past the floating point represent negative powers of 2

$$ \dots b_{2}b_{1}b_{0}.b_{-1}b_{-2} \dots = \dots  + b_{2}+2^3+b_{1}2^1+b_{0}2^0+b_{-1}2^{-1}+b_{-2}2^{-1} +\dots$$
where
$$ 2^{-1}= \frac{1}{2} = 0.5, \space 2^{-2} = \frac{1}{4} = 0.25, \space 2^{-3} = \frac{1}{8} = 0.125, \space \dots$$
Note: Some numbers such as 0.1 and 1/3 cannot be exactly represented in binary notation regardless of how many bits past the floating point are specified.

**Step 2:** Express the floating-point number in scientific notation

Recall in base-10 scientific notation, the number to the left of the decimal point must be 1-9 (unless the number is 0). 
Example:
![[Pasted image 20251006113914.png]]

In binary, the number to the left of the floating point must be a 1 (unless the number is zero).
Example:
![[Pasted image 20251006114040.png]]

**Step 3:** Fill in the various fields of the floating-point number appropriately
- *Sign bit:* 0 positive, 1 negative
- *Exponent*: Holds the exponent using a biased notation
- *Fraction*: Holds the fractional part of the significand in scientific notation.
	- The `1` before the floating point is implied and not stored.
	- Cannot represent zero
	- All bits after the last 1 are set to 0

1) Find bias (next section on [[#Biased Representation (excess 127 bias)]])
2) write down binary and split into sign, exponent, and fraction

**Example 1**

**Step 1:** Convert the decimal number into a binary number
![[Pasted image 20251006120414.png]]

**Step 2:** Express the floating-point number in scientific notation
![[Pasted image 20251006120513.png]]

**Step 3:** Fill in the various field s of the floating-point number appropriately
![[Pasted image 20251006120604.png]]

**Example 2**

![[Pasted image 20251006120707.png]]

### Biased Representation (excess 127 bias)

**Biased Representation**
Exponent is stored using an unusual biased representation. Think of it as a combination of two's complement and unsigned numbers:
- *Two's complement*: number line including both negative and positive numbers
- *Unsigned*: lowest number is all zeros; highest number is all ones.
Both properties are true in the biased representation.

![[Pasted image 20251006115024.png]]


**Excess 127 bias**
 For 8 bits, this form is called *excess 127 bias* because the numbers are 127 apart from the two's complement equivalent.
- Two's complement number -> excess 127 bias: 
	1)  Add +127 in it's two's complement form `0111 1111`
	2) Ignore overflow: Discard 9th digit
- Excess 127 bias -> Two's complement number:
	1) Add -127 in its two's complement form `1000 0001`
	2) Ignore overflow: Discard 9th digit

### Special Floating-Point Numbers

| zero                                                                             | infinity                                                                                    | NaN (not a number)                                                                              |
| -------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| - sign bit can be anything<br>- exponent is all zeros<br>- fraction is all zeros | - sign bit: 1(-infinity), 0(+infinity)<br>- exponent is all ones<br>- fraction is all zeros | - sign bit can be anything<br>- exponent is all ones<br>- fraction is anything except all zeros |
## Floating-Point Approximations and Errors

Issues: 
- Since the number of bits is finite, not every real number can be represented.
- Many values cannot be represented exactly. This introduces error or imprecision in each floating-point value and calculation
- By using a greater number of bits in the fraction, the magnitude of the error is reduced but errors can never totally be eliminated.

### Floating-Point Terminology

- The **range** of a numeric format is the difference between the largest and smallest values that is can express. 
	- 32-bit IEEE FP range: 1.2 x 10^(-38) to 3.4 x 10^(38)
- **Accuracy** refers to how closely a numeric representation approximates a true value
- The **precision** of a number indicates how much information we have about a value
	- The number of significant digits
- **Overflow** occurs when there is no room to store the high-order bits resulting from a calculation.
- **Underflow** occurs when a value is too small to store, possibly resulting in division by 0\

### Floating-Point Error

Must be aware that errors can compound through repetitive arithmetic operations:
- The order of operations can affect the error.
- Associative, commutative or distributive laws may no longer apply.
Best practice: use operands similar in magnitude

**Example**
``` C++
int main()
{
	int i;
	float a, b;
	
	a = 0.0;
	a = a + 10000000;
	for (i = 0; i < 20000000; i++) {
		a = a + 0.5;
	}
	std::cout << "a = " << a << std::endl;
	
	b = 0.0;
	for (int i = 0; i < 20000000; i++) {
		b = b + 0.5;
	}
	b = b + 1000000;
	std::cout << "b = " << b << std::endl;
	
	return 0;
}
// In this code a = 1 x 10^7, b = 1.83886 x 10^7
// or 
// a = 10 million, b = 18.3 million
```

## Additional Arithmetic
### Floating-Point Addition

steps:
1) Check for any special values: zero, infinity, NaN
2) Shift value with smaller exponent right to match larger exponent
3) Add two values (or subtract if signs are different)
4) Normalize the value (in the form 1.bbb) and update exponent
5) Check for zero and overflow

### Floating-Point Multiplication

1) Check for any special values: zero, infinity, NaN
2) Fill in sign based on sign of the two values
	- ignore sign for remaining steps
3) Multiply fractions
4) Multiply exponents (add them together)
5) Normalize the product (int the form 1.bbb) and update exponent
6) Check for overflow and underflow