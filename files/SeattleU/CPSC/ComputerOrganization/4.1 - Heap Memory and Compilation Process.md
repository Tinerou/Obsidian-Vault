#ComputerOrganization
### Heap Memory

#### Dynamic Memory
**Heap** 
The heap is used to store dynamic memory
There are 2 parts to the heap:
1) Heap data: Memory that can be allocated and deallocated.
2) Heap management: Consists of a table that keeps track of what memory is already allocated and what memory is free.
The heap management table is stored in the heap area (too complicated to store in registers).
Different ways of managing the table - independent of the ISA (Instruction Set Architecture)

**Allocation and Deallocation**
To *allocate* memory of size $n$:
- Look up the heap management table and find a free block of size $n$. 
- Mark the block as used.
- Return the address of the block
To *deallocate memory*:
- Find the address in the heap management table
- Mark the block as free

**Memory Regions in ANNA**
ANNA programs can have all four sections in this order (A little different than other programs):
1) Code (fixed size) 
2) Data (fixed size)
3) Heap (dynamically sized)
4) Stack (dynamically sized, starts at address `0x8000`)
![[Pasted image 20251031133939.png|234x311]]

#### Dynamic Memory in ANNA

- Dynamic memory in ANNA is simplified - only allocations (no deallocations)
- Heap management table is implemented using a single pointer
	- pointer points to next free word in memory
	- All memory in heap prior to pointer is used
Heap is placed at the end of the program:
```Assembly
# heap section
heapPtr: .fill &heap   # points to the start of &heap
heap: .fill 0
```

![[Pasted image 20251103131358.png|318x368]]


#### Allocating Memory in ANNA

##### Example 1
Convert to ANNA: `int *p = new int[n];`
Assume `n >= 1` and is in `r1` and assume `p` is in `r2`.
```Assembly
lli r3 &heapPtr
lui r3 &heapPtr
lw r2 r3 0
add r4 r2 r1
sw r4 r3 0

# convert p[3] = 5
lli r5 5
sw r5 r2 3
```
![[Pasted image 20251103132126.png]]
##### Example 2
Convert C++ snippet to ANNA:
```C++
Node* p = new Node;
p->val = x;
p->next = q;

struct Node {
	int val; // 0
	Node* next; // 1
}
```
With registers:
`p: r1`
`x: r2`
`q: r3`

```Assembly
lli r4 &heapPtr
lui r4 &heapPtr
lw r1 r4 0
addi r5 r1 2
sw r5 r4 0
sw r2 r1 0
sw r3 r1 1
```

![[image-3.png]]

### Memory Errors

#### Memory for Real Programs
- The operating system places memory limits on a program.
	- Program has a segment or range of allowable addresses.
		- Unlike ANNA where all addresses are allowed
	- Limits size of stack and heap
- `NULL` is a special reserved address (often `0`) that is used for pointers that don't point to anything.
- Actually more complex: virtual memory and paging (both covered in CPSC 3500 class)
	- because multiple programs are running at the same time

#### Memory Errors

Here's the table in Markdown format:

| Error Type                       | Description                                                                                                        | Typical Cause                                                                                                 |
| -------------------------------- | ------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------- |
| **Segmentation fault**           | Accessing an address that is outside the program's segment (allowable range of addresses)                          | Dereferencing an uninitialized pointer                                                                        |
| **Null pointer dereference**     | Dereferencing a pointer that is `NULL`                                                                             |                                                                                                               |
| **Stack overflow**               | Limit on stack is reached, not enough space to push another activation record                                      | Infinite recursive loop                                                                                       |
| **Heap overflow**                | Limit on heap is reached, not enough space to handle allocation                                                    | Infinite loop that allocates memory each iteration; Could be due to memory demands of program exceeding limit |
| **Array out-of-bounds**          | Using an index that is outside the bounds of the array                                                             | Accessing array elements beyond allocated size, or negative.                                                  |
| **Buffer Overflow**              | Writing data to a buffer that exceeds the boundary and overwrites adjacent memory locations.                       |                                                                                                               |
| **Double free**                  | Trying to deallocate memory that already has been deallocated.                                                     |                                                                                                               |
| **Invalid free**                 | Trying to deallocate a memory that was never dynamically allocated or not using the starting address of the block. |                                                                                                               |
| **Dangling pointer dereference** | Trying to dereference a pointer that is pointing to memory that was previously deallocated                         |                                                                                                               |
| **Memory leak**                  | Not deallocating memory once the memory is no longer needed                                                        |                                                                                                               |
#### Handling Memory Errors

| Strategy                     | Explanation                                                            | Other                                                                                                            |
| ---------------------------- | ---------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| **Exceptions**               | Automatically detect and throw exceptions if a memory error occurs     | - User can catch the exception and try to recover<br>- If exception is not caught, program is aborted.           |
| **Garbage collection**       | Automatically delete memory that is no longer needed.                  | - No explicit deallocation<br>- Memory leaks less likely but still possible due to garbage collector limitations |
| **Language limitations**     | Limit pointer operations such that they cannot ponit to invalid memory |                                                                                                                  |
| **Programmer detection**     | Programmer checks for violations in the code.                          |                                                                                                                  |
| **Program crashes / aborts** | Program will crash or abort if a memory occurs.                        | - Avoids incorrect output                                                                                        |
#### Memory Errors: C++ vs. Java
![[Pasted image 20251103132701.png]]

Why does c++ not detect errors like array out-of-bounds?
- Performance: it is faster to not check
Problems with this approach?
- Even good programmers can make mistakes. These mistakes can be undetected. 
- Buffer overflows could be a security risk

### Compilation Process

![[Pasted image 20251103133044.png]]

#### Compiler
The **compiler** converts C++ (or any language) into assembly code.

In g++, run compiler using `-S`:
	- `g++ -S prog.cpp`   ← (produces prog.s)
Two major parts:
- *front-end:* 
	- Parses high level language
	- Checks for syntax errors
- *back-end:*
	- Optimizes code
	- Allocates registers
	- Produces assembly code
##### Performance Optimizations
*Register allocation:* Place frequently used variables in registers instead (or addition to) of memory on the stack.

*Function inlining:* Instead of calling the function, copy the code into the caller function instead.
- Reduces overhead of function call.
- Increases the size of the program.

The compiler can apply these optimizations.
- In C++, the keyword `inline` can be used to tell the compiler that you want a function to be inlined.
	- The request is non-binding - the compiler may or may not honor the request.

#### Assembler
The **assembler** converts assembly file (`.s` file) to object file (`.o` file).

In g++, use `-c` to stop at the object code level:
- `g++ -c prog.s`           (both produce `prog.o`)
- `g++ -c prof.cpp`

Generally a simple translation: Assembly instructions map to a machine instruction.
- Assembler provides directives, pseudo-instructions, and labels to make programming easier.

The assembler typically makes two passes.
- During the first pass, it determines the addresses of the labels.
- The actual conversion to machine code occurs during the second pass.
##### Multiple File Compilation
- Individual source code files are compiled and assembled separately into the own object file.
- The linker is responsible for linking the individual object files into a single executable.
- Even if all the code were contained in a single code, the object file is still not executable: the format of an object file and executable are different.
- A **library** is a package of (related) object files.
##### Producing Machine Code
The assembler does not have enough information to produce executable machine code.

References to labels in another file:
- May need to call a function in another file.
- May need to access a variable in another file.
- Cannot fill in the immediate values.

Assembler assumes file starts at address `0` (or another fixed address).
- Not every file can start at `0`.
- Need to relocate the file and change the direct addresses.

#### **Linking Example**
![[image-38.png]]
#### Object Files
An **object file** contains more than machine code. The format of an object file is as follows:
![[image-39.png|272x226]]
- *Identification:* Contains the starting points and sizes of the remaining sections and other i formation needed by the linker.
- *Symbol Table, External Reference List, Relocation Records* (explained later, in detail…).
- *Code:* Contains the machine code (sometimes called "*text*").
- *Data/Constants:* Contains initialized global variables and constants.
- *Debug Info:* Additional information regarding variable names and source code line numbers that is used by debuggers.
	- This section is only present if compiled with debugging turned on (`-g` in g++).
- *End of module:* Marks the end of the object file, possibly with a checksum to check for corrupt files and additional information.
##### Symbol Table
**Symbol Table:** A table of `<label, address>` pairs that are visible to other object files.
- Labels correspond to functions and global variables that other object files might want to access.
	- Example: If object file $A$ has defined function `foo`, an entry to `foo` with its starting address appears in the symbol table.
- Only "global" labels are in the symbol table.
	- Global variables and functions (based on scoping rules) are visible.
	- Labels for branch targets are not visible.
- Each global name must be unique.
	- The linker will report an error if the same global label appears multiple times.
##### External Reference List
**External Reference List:** A list of labels used in this file but are not defined and expected to be defined in another file.
- Contains a list of functions called, and global variables used, that are not defined in the current file.
	- Example: If object file B calls `foo` but `foo` is defined in a different file, the label `foo` will appear in the external reference list.
- Linker will report an error if a label in the external reference list is not defined elsewhere.
##### Relocation Records
**Relocation Records:** Contains a list of instructions or data entries that use a label that refers to direct address.
- Applies to instruction like this: `lli r4 &foo`
- Does not apply to labeled instructions: `foo: sw r6 r7 0`

Direct addresses include labels for functions and variables in the data section.
- Includes both labels defined in the file and labels defined elsewhere (i.e. in the external reference list).

If the linker relocates an instruction to a different place in memory, the immediate will be updated with their new address.

Relocation records are NOT created for PC-relative targets in branches.
- Since code within a file remains together during linking, the offsets will remain the same.
#### Linker
The **linker** stitches independently created object files into a single executable file:
1) Gather the addresses for all labels in the entry point tables.
	- An error occurs if the same label appears twice.
2) Replace all external references with the appropriate addresses.
	- An error occurs if an external reference is not found.
3) Place all the code together into one code section.
	- The code in each file is guaranteed to stay together.
4) Place all the data together into one data section.
5) Relocate all the addresses reference in the program to reflect the new address.
	- Not needed for PC-relative targets.
6) Produce the executable file.
#### Loader
The **loader** copies the executable file from disk into memory.
- Asks the operating system to schedule the executable as a new process
- Used to be a straightforward process.
	- Now portions of the compiling / assembly / linking process are deferred to load time (or even run time).
#### Dynamically Linked Libraries (DLLs)
**Dynamically linked libraries** are not linked nor loaded until run-time.
- Many system libraries are linked dynamically.
- *Advantages:*
	- Only load portions of the program that are actually executed.
	- Multiple processes can share the same code in memory.
	- Easier to update libraries (don't need to recreate new executables).
- *Disadvantages:*
	- Slower - overhead due to linking while the program is running.
	- Complexity - OS support is needed.