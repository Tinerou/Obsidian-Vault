#ComputerOrganization
### Heap Memory

#### Dynamic Memory
**Heap** 
The heap is used to store dynamic memory
There are 2 parts to the heap:
1) Heap data: Memory that can be allocated and deallocated.
2) Heap management: Consists of a table that keeps track of what memory is already allocated and what memory is free.
The heap management table is stored in the heap area (too complicated to store in registers).
Different ways of managing the table - independent of the ISA (Instruction Set Architecture)

**Allocation and Deallocation**
To *allocate* memory of size $n$:
- Look up the heap management table and find a free block of size $n$. 
- Mark the block as used.
- Return the address of the block
To *deallocate memory*:
- Find the address in the heap management table
- Mark the block as free

**Memory Regions in ANNA**
ANNA programs can have all four sections in this order (A little different than other programs):
1) Code (fixed size) 
2) Data (fixed size)
3) Heap (dynamically sized)
4) Stack (dynamically sized, starts at address `0x8000`)
								![[Pasted image 20251031133939.png]]

#### Dynamic Memory in ANNA

- Dynamic memory in ANNA is simplified - only allocations (no deallocations)
- Heap management table is implemented using a single pointer
	- pointer points to next free word in memory
	- All memory in heap prior to pointer is used
Heap is placed at the end of the program:
```Assembly
# heap section
heapPtr: .fill &heap   # points to the start of &heap
heap: .fill 0
```

![[Pasted image 20251103131358.png]]


#### Allocating Memory in ANNA

##### Example 1
Convert to ANNA: `int *p = new int[n];`
Assume `n >= 1` and is in `r1` and assume `p` is in `r2`.
```Assembly
lli r3 &heapPtr
lui r3 &heapPtr
lw r2 r3 0
add r4 r2 r1
sw r4 r3 0

# convert p[3] = 5
lli r5 5
sw r5 r2 3
```
![[Pasted image 20251103132126.png]]
##### Example 2
Convert C++ snippet to ANNA:
```C++
Node* p = new Node;
p->val = x;
p->next = q;

struct Node {
	int val; // 0
	Node* next; // 1
}
```
With registers:
`p: r1`
`x: r2`
`q: r3`

```Assembly
lli r4 &heapPtr
lui r4 &heapPtr
lw r1 r4 0
addi r5 r1 2
sw r5 r4 0
sw r2 r1 0
sw r3 r1 1
```

### Memory Errors

#### Memory for Real Programs
- The operating system places memory limits on a program.
	- Program has a segment or range of allowable addresses.
		- Unlike ANNA where all addresses are allowed
	- Limits size of stack and heap
- `NULL` is a special reserved address (often `0`) that is used for pointers that don't point to anything.
- Actually more complex: virtual memory and paging (both covered in CPSC 3500 class)
	- because multiple programs are running at the same time

#### Memory Errors

Here's the table in Markdown format:

| Error Type                       | Description                                                                                                        | Typical Cause                                                                                                 |
| -------------------------------- | ------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------- |
| **Segmentation fault**           | Accessing an address that is outside the program's segment (allowable range of addresses)                          | Dereferencing an uninitialized pointer                                                                        |
| **Null pointer dereference**     | Dereferencing a pointer that is `NULL`                                                                             |                                                                                                               |
| **Stack overflow**               | Limit on stack is reached, not enough space to push another activation record                                      | Infinite recursive loop                                                                                       |
| **Heap overflow**                | Limit on heap is reached, not enough space to handle allocation                                                    | Infinite loop that allocates memory each iteration; Could be due to memory demands of program exceeding limit |
| **Array out-of-bounds**          | Using an index that is outside the bounds of the array                                                             | Accessing array elements beyond allocated size, or negative.                                                  |
| **Buffer Overflow**              | Writing data to a buffer that exceeds the boundary and overwrites adjacent memory locations.                       |                                                                                                               |
| **Double free**                  | Trying to deallocate memory that already has been deallocated.                                                     |                                                                                                               |
| **Invalid free**                 | Trying to deallocate a memory that was never dynamically allocated or not using the starting address of the block. |                                                                                                               |
| **Dangling pointer dereference** | Trying to dereference a pointer that is pointing to memory that was previously deallocated                         |                                                                                                               |
| **Memory leak**                  | Not deallocating memory once the memory is no longer needed                                                        |                                                                                                               |
#### Handling Memory Errors

| Strategy                     | Explanation                                                            | Other                                                                                                            |
| ---------------------------- | ---------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| **Exceptions**               | Automatically detect and throw exceptions if a memory error occurs     | - User can catch the exception and try to recover<br>- If exception is not caught, program is aborted.           |
| **Garbage collection**       | Automatically delete memory that is no longer needed.                  | - No explicit deallocation<br>- Memory leaks less likely but still possible due to garbage collector limitations |
| **Language limitations**     | Limit pointer operations such that they cannot ponit to invalid memory |                                                                                                                  |
| **Programmer detection**     | Programmer checks for violations in the code.                          |                                                                                                                  |
| **Program crashes / aborts** | Program will crash or abort if a memory occurs.                        | - Avoids incorrect output                                                                                        |
#### Memory Errors: C++ vs. Java
![[Pasted image 20251103132701.png]]

Why does c++ not detect errors like array out-of-bounds?
- Performance: it is faster to not check
Problems with this approach?
- Even good programmers can make mistakes. These mistakes can be undetected. 
- Buffer overflows could be a security risk

### Compilation Process

![[Pasted image 20251103133044.png]]

â€¦ continue here