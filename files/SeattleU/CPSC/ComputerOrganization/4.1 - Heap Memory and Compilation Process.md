#ComputerOrganization
### Heap Memory

#### Dynamic Memory
**Heap** 
The heap is used to store dynamic memory
There are 2 parts to the heap:
1) Heap data: Memory that can be allocated and deallocated.
2) Heap management: Consists of a table that keeps track of what memory is already allocated and what memory is free.
The heap management table is stored in the heap area (too complicated to store in registers).
Different ways of managing the table - independent of the ISA (Instruction Set Architecture)

**Allocation and Deallocation**
To *allocate* memory of size $n$:
- Look up the heap management table and find a free block of size $n$. 
- Mark the block as used.
- Return the address of the block
To *deallocate memory*:
- Find the address in the heap management table
- Mark the block as free

**Memory Regions in ANNA**
ANNA programs can have all four sections in this order (A little different than other programs):
1) Code (fixed size) 
2) Data (fixed size)
3) Heap (dynamically sized)
4) Stack (dynamically sized, starts at address `0x8000`)
								![[Pasted image 20251031133939.png]]

#### Dynamic Memory in ANNA

- Dynamic memory in ANNA is simplified - only allocations (no deallocations)
- Heap management table is implemented using a single pointer
	- pointer points to next free word in memory
	- All memory in heap prior to pointer is used
	- 
Heap is placed at the end of the program:
```Assembly
# heap section
heapPtr: .fill &heap   # points to the start of &heap
heap: .fill 0
```

…

#### Allocating Memory in ANNA

##### Example 1
Convert to ANNA: `int *p = new int[n];`
Assume `n >= 1` and is in `r1` and assume `p` is in `r2`.
…
##### Example 2
Convert C++ snippet to ANNA:
With registers:
`p: r1`
`x: r2`
`q: r3`

```C++
Node* p = new Node;
p->val = x;
p->next = q;

struct Node {
int val; // 0
Node* next; // 1
};
```
### Memory Errors

#### Memory for Real Programs
- The operating system places memory limits on a program.
	- Program has a segment or range of allowable addresses.
		- Unlike ANNA where all addresses are allowed
	- Limits size of stack and heap
- `NULL` is a special reserved address (often `0`) that is used for pointers that don't point to anything.
- Actually more complex: virtual memory and paging (both covered in CPSC 3500 class)
	- because multiple programs are running at the same time

#### Memory Errors

Here's the table in Markdown format:

| Error Type                       | Description                                                                                                        | Typical Cause                                                                                                 |
| -------------------------------- | ------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------- |
| **Segmentation fault**           | Accessing an address that is outside the program's segment (allowable range of addresses)                          | Dereferencing an uninitialized pointer                                                                        |
| **Null pointer dereference**     | Dereferencing a pointer that is `NULL`                                                                             |                                                                                                               |
| **Stack overflow**               | Limit on stack is reached, not enough space to push another activation record                                      | Infinite recursive loop                                                                                       |
| **Heap overflow**                | Limit on heap is reached, not enough space to handle allocation                                                    | Infinite loop that allocates memory each iteration; Could be due to memory demands of program exceeding limit |
| **Array out-of-bounds**          | Using an index that is outside the bounds of the array                                                             | Accessing array elements beyond allocated size, or negative.                                                  |
| **Buffer Overflow**              | Writing data to a buffer that exceeds the boundary and overwrites adjacent memory locations.                       |                                                                                                               |
| **Double free**                  | Trying to deallocate memory that already has been deallocated.                                                     |                                                                                                               |
| **Invalid free**                 | Trying to deallocate a memory that was never dynamically allocated or not using the starting address of the block. |                                                                                                               |
| **Dangling pointer dereference** | Trying to dereference a pointer that is pointing to memory that was previously deallocated                         |                                                                                                               |
| **Memory leak**                  | Not deallocating memory once the memory is no longer needed                                                        |                                                                                                               |
#### Handling Memory Errors

| Strategy                 | Explanation                                                        | Other                                                                                                            |
| ------------------------ | ------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------- |
| **Exceptions**           | Automatically detect and throw exceptions if a memory error occurs | - User can catch the exception and try to recover<br>- If exception is not caught, program is aborted.           |
| **Garbage collection**   | Automatically delete memory that is no longer needed.              | - No explicit deallocation<br>- Memory leaks less likely but still possible due to garbage collector limitations |
| **Language Limitations** |                                                                    |                                                                                                                  |
