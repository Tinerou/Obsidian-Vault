#ComputerOrganization 

### Performance (CPU Time and Single vs Multiple Cycle Datapaths)

What factors are important when considering performance of a computer system?
- I/O Performance
	- One thing that comes to mind for input/output is GPU (Graphics Processing Unit)
- How many operations per second?
- Memory (how much, access speed, type)
- Power
#### CPU Time Equation
$$CPU \space Time = \frac{seconds}{program} = \frac{instructions}{program}* \frac{avg \space cycles}{instruction}* \frac{seconds}{cycle}$$

$\frac{instructions}{program}$ ← "dynamic" instruction count

$\frac{avg \space cycles}{instruction}$ ← Cycles per instruction (CPI)

$\frac{seconds}{cycle}$ ← Inverse of frequency

#### Misleading / Deceptive statistic Practices
- Only providing clock frequency (often given in GHz).
- Using statistics such as MIPS (Millions of Instructions Per Second) / FLOPS (Floating Point Operations Per Second).
- Selective statistics: Citing only favorable results while omitting others.
- Using biased or irrelevant benchmarks.
- Citing only peak performance numbers while ignoring the average case.
- Vagueness in the use of words like "almost," "nearly," "more," and "less," in comparing performance data.
#### Measuring Performance
Measuring performance is hard!
- Hard to come up with representative and realistic set of benchmarks.
- The compiler and how the program is written factor into the overall time.
- Dependencies on I/O devices, operating systems, libraries, etc.
- Measuring CPU usage at a fine-grained level can be challenging
- Different input sizes can drastically change the results

#### Single Cycle Datapath
- CPI: 1 (every instruction takes 1 cycle)
- Cycle time (inverse of frequency) is set based on time for longest instruction.
- Longest instruction is typically `lw`:
	- Read base address of register
	- Compute effective address using ALU
	- Get value from memory
	- Write value from memory to register file
- Problem: All other instructions waste time.

#### Multiple Cycle Datapath
- Instructions can take multiple cycles to execute.
- Longer instructions take more cycles; shorter instructions take fewer cycles.
- Cycle time is shorter → Less work per cycle
- Is multiple cycle faster than single cycle?

Cycle time is shorter → Improves performance (decreases time)
CPI is higher → Decreases performance (increases time)

##### In class problem
…

### Pipelining

#### What is pipelining?
![[image-25.png|532x319]]
![[image-26.png|531x306]]
- Each instruction does a executes a specific part of its function at once.

#### Pipelined Implementation in ANNA
- Break the execution of the instructions into cycles. 
	- Similar to the multiple cycle datapath.
- Design a separate datapath stage for the execution performed during each cycle.
- Instruction can overlap execution
	- Different instructions can be in different cycles
- Build pipeline registers to communicate between different stages.

#### 5 Stages of ANNA Pipeline
![[image-27.png|586x453]]

**Stage 1: Fetch (IF)**
- Design a datapath that can fetch an instruction form memory every cycle.
	- Use PC to index instruction memory.
	- Increment the PC (assume no branches for now).
- Write everything needed to complete the execution to the pipeline register (*IF/ID*).
	- The next stage will read this pipeline register.
![[image-28.png|537x389]]

**Stage 2: Decode (ID)**
- Reads the IF/ID pipeline register and decodes instruction.
	- Decode is easy: pass opcode to later stages and let them figure out what to do.
- Reads register file.
- Determine immediate (based on instruction).
- Write everything needed to complete execution to pipeline register (*ID/EX*):
	- register values
	- immediate
	- opcode and destination register number (could pass entire instruction)
	- PC+1 (even though decode doesn't use it)
![[image-29.png|598x440]]

**Stage 3: Execute (EX)**
- Performs the proper ALU operation for the instruction specified and the values present in the ID/EX pipeline register.
- Calculates target address in case this is a branch.
	- Also determines if branch is taken or not.
- Write everything needed to complete execution to the pipeline register (*EX/MEM*):
	- ALU result
	- Contents of register src2 (store data)
	- target address (branches)
	- result from branch detection unit
	- instruction bits for opcode and destination register
![[image-30.png|617x448]]

**Stage 4: Memory (MEM)**
- Performs the proper memory operation based on the instruction in EX/MEM pipeline register.
- Also resolves taken branches (more on this later).
- Nothing is done for ALU operations
- Write everything needed to complete execution to the pipeline register (*MEM/WB*)
	- ALU result
	- data from memory (result of load)
	- instruction bits for opcode and destination register
![[image-31.png|585x452]]

**Stage 5: Write back (WB)**
- Completes execution of instruction by writing a value back to the register file.
- Instructions that do not write back to the register file do not do anything.
![[image-32.png|559x407]]


#### Example program

Run the following program on pipeline ANNA processor:
```Assembly
add r1 r2 r3         // PC = 20
lw r4 r5 1
and r6 r2 r3
sw r7 r5 9
or r4 r3 r7
```

![[image-33.png]]![[image-34.png]]![[image-35.png]]![[image-36.png]]![[image-37.png]]![[image-38.png]]![[image-39.png]]![[image-40.png]]![[image-41.png]]![[image-42.png]]