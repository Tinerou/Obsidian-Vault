#ComputerOrganization 
### Branches

**Branches** allow the programmer to jump to another portion of code
- The set the PC to something other than PC+1
*Conditional branch* instructions are based on a condition: 
if (`condition_test`) go to `target_address`
- Only jumps to `target_address` if `condition_test` is true
- Continue to PC+1 if false

#### There are 6 conditional branch instructions in ANNA:

| instruction    | action                                            |
| -------------- | ------------------------------------------------- |
| `beq`$R_DImm8$ | branch if equal to zero ($=0$)                    |
| `bne`$R_DImm8$ | branch if not equal to zero ($\neq0$)             |
| `bgt`$R_DImm8$ | branch if greater than zero ($\gt0$)              |
| `bge`$R_DImm8$ | branch if greater than or equal to zero ($\geq0$) |
| `blt`$R_DImm8$ | branch if less than zero ($\lt0$)                 |
| `ble`$R_DImm8$ | branch if less than or equal to zero ($\leq 0$)   |
- Register $R_D$ is used in the condition test
	- Compares the contents of register $R_D$ to zero
	- If true, branch to target address
	- If false, continue to PC+1
- $Imm8$ is used to compute the target address
	- The *target address* is computed: $PC+1+Imm8$
	- The immediate is an 8-bit signed number

#### Fetch and Execute Loop for branch instructions
1) Fetch the instruction at the offset in memory indicated by the PC
2) Set PC ‚Üê PC+1
3) Get the value of the register
4) Compare the value of the register to 0.
5) (If taken/true) Compute the target address (PC + $Imm8$)
6) (If taken/true) Update PC

#### Branch Usage
- Branches are used in control statements such as if, switch, and loops
- Target address is typically close to the instruction
	- Could use multiple branches if farther than offset limit
- May need unconditional branch, if so use:
	- `beq r0 <offset>`
	- `<offset` is explained in [[#PC-Relative Addressing]]
- Function calls and returns don't use branches, they use `jalr` instead

#### PC-Relative Addressing
**PC-relative addressing:** creating an address by using the current value of the PC.
- The offset is the number of instructions away you want to jump
	- Negative offset: jump backwards
	- Positive offset: jump forwards
- (Most) offsets can fit within the immediate, a direct address would require two instructions (like `lli` and `lui`).
- Problem: If the code is modified, the offsets may change
	- Solution: Use labels

#### Labels
**Labels** can optionally precede any instruction.
Rules:
- Only one label per instruction (must be on the same line)
- A label name can only be declared once
- A label is a string followed by a colon (colon is not part of label)
- The label can be referenced in 8-bit immediate operands of other instructions
	- Cannot be used of I6-type instructions
	- Must be preceded by `&` 
	- The assembler replaces the label using the address of the instruction marked by the label

#### Labels for branches
When a label is used as an immediate for a branch instruction, the assembler will automatically determine the proper offset.
Example:
```Assembly
beginLoop: add r3 r4 r5
...
bgt r4 & beginLoop
```
- An error occurs if the address is too far away


### If Statements

#### Comparing two numbers
**USE SUBTRACTION**

Let $temp = x-y$

| operation  | mathematical ans | ANNA command |
|:----------:|:----------------:|:------------:|
|  $x == y$  |    $temp = 0$    |    `beq`     |
| $x\neq y$  |  $temp \neq 0$   |    `bne`     |
|   $x>y$    |     $temp>0$     |    `bgt`     |
| $x \geq y$ |  $temp \geq 0$   |    `bge`     |
|  $x < y$   |    $temp < 0$    |    `blt`     |
| $x \leq y$ |  $temp \leq 0$   |    `ble`     |

#### If statement examples

##### Example 1
Convert this code to ANNA assembly.
Assume `x` is in `r3` and `y` is in `r4` and both are integers
```C++
if (x == y) {
	x++;
else 
	y++;
x = x - y;
}
```

```Assembly
	sub r5 r3 r4      # r5 = x-y
	beq r5 &then      #if (r5 == 0) go to then:
	beq r0 &else      # else go to else:
then: addi r3 r3 1    # increment r3
	beq r0 &endif     # go to endif:
else: addi r4 r4 1    # increment r4
	beq r0 &endif     # go to endif:
endif: sub r3 r3 r4   # r3 = r3 - r4
	
```

![[Pasted image 20251021195058.png]]

##### Example 2
Convert this code to ANNA assembly.
Assume `x` is in `r3` and `y` is in `r4` and both are integers
```C++
if (x >= y) {
	x++;
else 
	y++;
x = x - y;
}
```

```Assembly
	sub r5 r3 r4
	bge r5 &then
	beq r0 &else
then: addi r3 r3 1
	beq r0 &endif
else: addi r4 r4 1
	beq r0 &endif
endif: sub r3 r3 r4
```

##### Example 3
Convert this code to ANNA assembly.
Assume `x` is in `r3` and `y` is in `r4` and both are integers
```C++
if ((x==y) && (x>0)) {
	x++;
else 
	y++;
x = x - y;
}
```

```Assembly
	sub r5 r3 r4
	beq r5 &cond2
	beq r0 &else
cond2: bgt r5 &then
	beq r0 &else
then: addi r3 r3 1
	beq r0 &endif
else: addi r4 r4 1
	beq r0 &endif
endif: sub r3 r3 r4
```

##### In class answers for Example 4 and 5
![[Pasted image 20251021201650.png]]

### Loops