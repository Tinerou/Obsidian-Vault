#ComputerOrganization 

### Intro

- **Assembly** language is a low level programming language that provides direct access to registers and memory
- Assembly language is dependent on the microprocessor family
- An assembly language program consists of a sequence of instructions
- There is a direct correspondence between an assembly language instruction and a machine language instruction (raw 1s and 0s)
- Fixed size

#### ANNA Architecture

**Characteristics**:
- 16-bit data words (can represent two's complement integers or addresses)
- 16-bit instructions
- $(2^{16}$) 64K words of word-addressable main memory
- 20 different instructions
- 8 general purpose 16-bit registers (numbered for `r0` to `r7`)
- 16-bit ALU
- 16-bit program counter (PC)
- Register `r0` always has the value 0
- No hardware support / instructions for floating point values

#### Assembly Language Programming Process

Assembly language programming process (in ANNA):
1) Write the program in assembly language(save to a `.ac` file)
2) Assemble the program using an assembler (No news is good news)
3) Execute the machine code file in a simulator

#### Registers and Variables
##### Registers
Registers are memory locations inside the CPU
- Registers can be: `r0 r1 r2 r3 r4 r5 r6 r7`
- Remember that `r0` is always 0, even if you try to write to it.
Variables within a program can either be stored in memory or registers.
- In addition, registers need to store temporary values of longer expressions such as:
	- `a = 3 * b + c / d;`
- Note: In this unit we are going to assume that all variables are stored in registers. Later, we will discuss how to handle variables stored in memory
##### Variables
For C++ examples
- Assume that `int` refers to a 16-bit integer
- Assume that addresses are 16-bits
Assume that overflow does not occur
#### Program Counter

The **program counter(PC)** is a special register that keeps track of the address of which instruction is currently executing
- The machine program is stored in memory starting at address 0.
- The PC cannot be directly accessed by assembly instructions
- The PC is incremented each instruction
- Some instructions (branches and jumps) can update the PC (without incrementing).
	- Needed to implement control decisions (if/switch), loops, and function calls

#### ANNA Simulator

The simulator performs these steps upon startup
1) Each location in memory  is filled with 0.
2) All registers are set to 0
3) The program counter(PC) is set to 0
4) The program is loaded int memory starting at address 0

After startup, the simulator is then controlled by the user. The simplest command is to run the program. When running, the simulator:

1) Fetches the instruction at PC
2) Executes the instruction
3) Updates PC (typically PC+1)
4) repeats steps 1-3 until the program halts

#### Assembly Instructions

- All instructions have a name that describes the operation
- Most instructions have up to 3 operands that specify:
	- Where to get data that is used by the instruction (registers, memory, input, the instruction itself)
	- Where to put data that is produced by the instruction (registers, memory, output).
- The name and operands are delimited by spaces.
- Each instruction appears on its own line (no semicolons to delimit instructions)

#### Comments and Assembler Directives
- Comments are specified using '#'
- In addition to the 20 instructions, the ANNA assembler support 2 assembler directives (`.halt` and `.fill`).
	- Assembler directives are commands to the assembler

---
### Arithmetic and Logic Instructions

#### Add (Many will use this same concept)

`add` has the following format:
`add` $R_DR_AR_B$       $R(R_{D})$←$R(R_A)+R(R_B))$

Example:
`add r3 r2 r7`         R(`r3`) = R(`r2`)+R(`r7`)
`add r5 r5 r5`         R(`r5`) = R(`r5`)+R(`r5`)

Note:
- This instruction only accesses registers, it does not access memory
- Overflow is not detected for this or any other instruction(programmers responsibility)

#### Other Arithmetic and Logic Instructions
- These are *R-type* instructions as they only have register operands.
![[Pasted image 20251017131802.png]]

#### Fetch and Execute Loop

1) Fetch the instruction at the offset in memory indicated by the PC
2) Set PC ← PC+1
3) Get the value of the source register(s)
4) Perform the specified operation
5) Place the result into the destination register
#### Class Problem
![[Pasted image 20251017132713.png]]

---
### Input / Output Instructions

#### in
The input instruction `in` gets a word from input:
`in` $R_D$
- This instruction asks the user for a 16-bit number and places it into register $R_D$
- The input can be specified using either:
	- a signed number (-32,768 to 32,767)
	- a 4-digit hex number (0x0000 to 0xFFFF)
#### out
The output instruction `out` displays the contents of a register onto the screen:
`out` $R_D$
- The instruction displays contents of $R_D$ onto the screen in both decimal (two's complement) and hexadecimal format.

### Ending the Program
- The `out` instruction can also be used to halt the program: simply use `r0` as the register
	- The simulator will stop executing when an `out r0` instruction is executed
- For readability purposes, the assembler directive `.halt` can (and should) be used instead of `out r0`.
	- The directive `.halt` has no operands - it is simply shorthand for an `out r0` instruction


### Example Program
**add.ac**
```Assembly
in r1
in r2
in r3
add r4 r1 r2
add r4 r4 r3
out r4
.halt
```

### Arithmetic Instructions with Immediates

#### Immediates
**Immediate:** a constant value in an instruction
- Immediates allow assembly instructions to work with constant operands
	- For example, consider the C++ instruction:
		- `x = y+3;`
ANNA has 2 types of immediate instructions:
- *I6-type*: Two register operands and a 6-bit immediate
- *I8-type*: One register operand and an 8-bit immediate

#### addi (Add immediate)

The add immediate instruction `addi` has the following format:

`addi`$R_DR_AImm6$         $R(R_D)$←$R(R_A)+Imm6$

- This instruction adds the contents of register $R_A$ with the 6-bit immediate $Imm6$.
- The immediate is signed two's complement number that can range from -32 to 31.
Examples:
`addi r3 r5 -12`           R(`r3`)←R(`r5`)+(-12)
`addi r2 r2 1`               R(`r2`)←R(`r2`)+1 (increments `r2`)

#### shf (Shift)

The shift instruction has a similar format:
`shf` $R_DR_AImm6$ 

- The number of bits and direction of the shift is determined by the immediate:
	- If $Imm6$ is positive → shift the contents of $R_A$ left by $Imm6$ bits
	- If $Imm6$ is negative → shift the content of R_A logically right by $|Imm6|$ bits
		- absolute value of $Imm6$
Examples:
`shf r3 r4 2`          R(`r3`)←R(`r4`)<<2     (shift left 2 bits)
`shf r7 r6 -3`        R(`r7`)←R(`r6`)>>3     (shift right 3 bits)

#### lli / lui (Initialize Register)

Why do we need this?:
It would be nice to have an instruction that initializes a register based on a 16-bit immediate like this: `ir r3 12345` however, 16-bit immediates are not possible.

The load register immediate instructions`lli` and `lui` are used in tandem to initialize registers

**Format**: 
`lli` $R_DImm8$            load lower immediate
`lui`  $R_DImm8$           load upper immediate

| 15-8       | 7-0        |
| ---------- | ---------- |
| Upper half | Lower half |
- The `lli` instruction is used to initialize the lower 8 bits of register $R_D$
	- The lower 8 bits are copied from the immediate
	- The upper 8 bits of register $R_D$ are equal to bit 7 (sign bit) of the immediate (sign extension).
- The `lui` instruction is used to initialize the upper 8 bits (bits 15-8) of register $R_D$
	- The 8 bits of the immediate are copied into the upper 8 bits of register $R_D$
	- The lower 8 bits of register $R_D$ are unchanged

**Note**: 
- Only use `lli` instruction if initialization is 8 bits or less (-128 to 127)
- When executing `lli/lui` as a pair, the `lli` instruction must be executed first

In ANNA assembler ,there are 3 ways of specifying 8-bit immediates for `lli/lli`
- signed 16-bit decimal number: The appropriate 8 bits are placed in the immediate.
- 8-bit hexadecimal number: The 8 bits (two hex digits) represented by the hexadecimal number are place din the immediate
- labels: More on this later…
Example: These are the same (Note: 1500 = 0x05dc)
`lli r4 1500`                      `lli r4 0xdc`
`lui r4 1500`                      `lui r4 0x05`

#### Fetch and execute loop for immediate instructions
1) Fetch the instruction at the offset in memory indicated by the PC
2) Set PC ← PC + 1 
3) Get the value of the source register and/or immediate
4) Perform the specified operation
5) Place the result into the destination register

### Examples
1) Shift `r5` right 4 bits (writing back into `r5`)
	`shf r5 r5 -4`
2) Adding 12 to `r3`
	`addi r3 r3 12`
3) Adding 50 to `r3`. Be careful!
	`lli r4 50`
	`add r3 r3 r4`
4) Initializing `r6` with the value -2345
	`lli r6 -2345`
	`lui r6 -2345`