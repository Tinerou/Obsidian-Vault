#ComputerOrganization 

### Von Neumann Model

Named after John von Neumann, a famous mathematician who was a pioneer in this model.  
-  Model first used by EDSAC in 1949.  
- Still in use today.  

von Neumann computers have *five basic components*:  
– A central processing unit (CPU)  
– A main memory system  
– A control unit  
– Input equipment  
– Output equipment  

The key feature of the von Neumann machines is that it can carry out sequential instruction processing.  

#### Von Neumann Architectures

**Registers:** Memory inside the chip used to hold results temporarily.

**Program Counter:** A special register that keeps track of where you are in the program.

**Main Memory:** Stores the program and the data used/generated by the program.

**Control Unit:** Responsible for interfacing with memory and decoding instructions.

**Arithmetic-Logic Unit:** Performs simple operations on data.

![[Pasted image 20251010113901.png]]

#### Instruction Execution

1) *Fetch* the next instruction from memory
2) Update the program counter to point to the following instruction
3) Determine the type (*decode*) of instruction just fetched
4) If the instruction needs data from memory, determine where that data is and store it in a register.
5) *Execute* the instruction.
6) Store the results of the instruction in a register and/or memory
7) Got to *step 1* for the next instruction

**Fetch**
The control unit *fetches* the next instruction from memory using the program counter to determine where the instruction is located.
![[Pasted image 20251010114624.png]]

**Decode**
The instruction is *decoded* into a language that the ALU can understand.
![[Pasted image 20251010114728.png]]

**Gather Data**
Any data operands required to execute the instruction are fetched from memory and placed into registers within the CPU.
![[Pasted image 20251010114853.png]]

**Execute**
The ALU *executes* the instruction and places results in registers or memory.
![[Pasted image 20251010115032.png]]

#### Multi Core Processors

A single chip has multiple processing units
- Dual core has 2 processing units
- Quad core has 4 processing units
Allows multiple programs to be executed at once
Programs can also take advantage of multiple processing units
- Software must be specifically designed to do this
- Software is hard to write
Faster than having multiple processors(each on a separate chip)
- Processing elements are "closer"
- Communication off-chip is slow

---
### Adders

#### Adders and Half Adders

An **adder** computes the binary sum.
- Initially look at adding individual bits
- Then build a circuit that can add larger numbers


**Half adder:** adds 2 bits (A, B) to produce a sum (S) and a carry out bit ($C_{out}$)
**Half Adder Truth Table:**
![[Pasted image 20251010120753.png]]

**Full Adder:** adds three bits A, B, and carry in (C_(in)). Produces the sum (S) and carry out ($C_{out}$).
**Full Adder Truth Table:**
![[Pasted image 20251010121703.png]]

#### Why a full adder?

A full adder can be constructed using 2 half adders.
![[Pasted image 20251010121850.png]]
- Note: Ignore shifter (not relevant)

#### Ripple Carry Adder

To construct an $n$-bit adder, we can use $n$ full adders, chain together such that $C_{out}$ of bit $i$ is fed in as $C_{in}$ of bit $i+1$:
![[Pasted image 20251010122935.png]]

---

### Arithmetic Logic Unit (ALU)

The **Arithmetic Logic Unit (ALU)** is responsible for executing instructions that involve arithmetic and logical operations
**Inputs:** 
- data (two $n$-bit numbers)
- control lines (determines the operation to be performed by the ALU)
**Output:**
- result (one $n$-bit number)
- status flags (such as overflow)

**2-bit ALU**
![[Pasted image 20251010125249.png]]

#### ALU Block Diagram

To simplify this (especially for large amounts of bits) we use a block diagram:
- If there are $n$ operation, need $log_{2}n$ operation bits
- An adder uses the same symbol:
	- designated with a '+'
	- only adds (no operation line needed)
- A CPU may have one or more adders that are separate from the ALU
![[Pasted image 20251010125648.png|604x389]]

#### Subtraction Using Addition
Consider an ALU that only does addition and subtraction with one control line *f*:
**0** - Add ($A+B$)
**1** - Subtract $(A-B) = A+(-B)$
![[Pasted image 20251010125958.png]]

---
### Shifter

A **shifter** takes a series of bits and shifts the bits one bit to the left or one bit to the right.

#### Different Kinds of Shifters

Let $X$ be input and $Y$ be output. Assume we are shifting one byte:
- *Left Shifts:*
	- $Y_n=X_{n-1}$ for $n\neq0$
	- $Y_0 = 0$
![[Pasted image 20251010130803.png]]
- *Logical Right Shifts:*
	- $Y_n=X_{n+1}$ for $n \neq 7$
	- $Y_7=0$
![[Pasted image 20251010130846.png]]
- *Arithmetic Right Shifts:*
	- $Y_n=X_{n+1}$ for $n \neq 7$
	- $Y_7=X_7$
![[Pasted image 20251010130939.png]]
#### Shifting and Arithmetic
- Shifting a number left one bit is equivalent to multiplying by 2. (overflow possible)
- Shifting a number right one bit is equivalent to integer division by 2. (remainder is discarded)
- The arithmetic right shift keeps negative numbers negative
	- The sign bit is replaced

**Example** 
![[Pasted image 20251010131237.png]]

---
### Comparisons

![[Pasted image 20251010132733.png]]
![[Pasted image 20251010132753.png]]
