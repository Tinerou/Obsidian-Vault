#ComputerOrganization 

### Intro (Caller/Callee)
Functions calls are the most difficult concept to model in assembly language.

Terminology:
- *caller* function: the function making the call
- *callee* function: the function to execute
- For instance, if a statement in function `foo` calls function `bar`:
	- `foo` is the caller function
	- `bar` is the callee function

#### Caller Function

Upon a function call, the *caller* function needs to:
1) Pass parameters
2) See the point in code to return to (*return address*)
3) Jump to the beginning of the callee function

After the function call, the *caller* function needs to:
-  Get the return value

#### Callee Function
At the start of the function, the *callee* function needs to:
1) Extract parameters
2) Allocate space for local variables

At the end of the function, the *callee* function needs to :
1) Store the return value
2) Deallocate space for local variables
3) Jump back to the caller function

### Function Calls in Assembly

#### jalr
The final ANNA assembly instruction `jalr` ("Jump And Link Register"):
`jalr`$R_DR_A$
- jumps to an address stored in register and saves PC + 1 in a different register
- $R_D$ contains the address of the function to jump to 
- $R_A$ will contain the return address (PC+1)
Operation summary for `jalr`:
$R(R_A)← PC+1$
$PC←R(R_D)$
Note: `jalr` is used predominantly in function calls and uses direct addressing (not PC-relative).

**Fetch and Execute Loop**
Fetch and execute loop for jump and link register instruction:
1) Fetch the instruction at the offset in memory indicated by the PC.
2) Set PC ← PC+1
3) Store PC into register $R_A$.
4) Get the value of the register of $R_D$.
5) Update the PC.

##### Using Jalr in function calls
To call function `foo`:
```Assembly
lli r1 &foo
lui r1 &foo
jalr r1 r2

foo: ... # some function
```

To return from `foo`:
`jalr r2 r0` ← `r2` is the same return address register

##### Function call caveats
- No parameters were passed into `foo`.
- The function `foo` did not overwrite the return address stored in a register
	- `r2` still contains the return address, not overwritten.
- All registers and memory locations are "global" in that they are shared by all functions
	- A problem occurs if the *caller* has designated that `x` is stored in `r6` and then `foo` overwrites `r6`.

#### Caller Function
Upon a function call, the *caller* function needs to:
1) Pass parameters
2) Save the point in code to return to (*return address*)
3) Jump to the beginning of the callee function

After function call, the *caller* function needs to:
- Get the return value

#### Callee Function
At the start of the function, the *callee* function needs to:
1) Extract parameters
2) Allocate space for local variables

At the end of the function or anytime the function returns, the *callee* function needs to:
1) Store the return value
2) Deallocate space for the local variables
3) Jump back to the caller function

#### Function Call Implementation
For parameters, local variables, and return values, there are two options:
- Use *registers*: Easier and faster to use but there are very few registers
- Use program *stack*: Can handle as many variables as needed. (more on this later)
Different decisions can be made.
- Calling convention dictates how registers and the program stack are used during function calls. (more on this later)

##### Example: max
1) Write a function `max` that takes two integers and returns the integer that is greater (*callee*).
2) Write code that askes the user for two integers, calls `max`, and outputs the return value from `max` (*caller*)
3) Callee and caller function must agree on register usage…
	- `r1` - First parameter
	- `r2` - Second parameter
	- `r3` - Return address
	- `r4` - Return value

```Assembly
in r1
in r2
lli r7 &max
lui r7 &max
jalr r7 r3
out r4
```

```Assembly
max: sub r5 r1 r2
bge r5 &check
beq r0 &else
check: addi r4 r1 0
beq r0 &endif
else: addi r4 r2 0
endif: jalr r3 r0
```

![[image-2.png]]
### Stack Memory
#### Program Stack
The **program stack** keeps track of function calls.
- On function calls, an activation record is pushed onto the stack.
- On function return, an activation record is popped off the 
![[Pasted image 20251103225637.png]]
#### Activation Records
An **activation record** can contain the following:
- Parameters passed into the function
- Local variables
- Return address - point in the code where the called function needs to return to when completed
- Return value - temporary location for storing the return value
- Saved values from previous functions (restored at the end of the function)
- Additionally temporary values for long expressions

#### Stack and Frame Pointers
Two pointers are commonly used to keep track of the stack:
- The **frame pointer** points to the *start* of the current activation record.
- The **stack pointer** points to the *end* of the stack.

These pointers are typically stored in registers.
- Some instruction sets will have special registers designated for these pointers.
- Will be part of the calling convention in ANNA.

![[image.png]]

As shown above the *stack*(sp) and *frame*(fp) are changed during function calls.

There are activation records examples on slide 64 for Unit 4… Might include these later.