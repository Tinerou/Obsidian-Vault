## Fixed Length Integers and Overflow
### Fixed Length Integers
- Integers in a computer have finite length.
- An unsigned (nonnegative) integer of *n* bits can represent values of 0 to 2^n -1.
- In C++, you can find the number of bytes of a type using `sizeof()` operator.

| **Data Types** | **Size (bytes)** | **Unsigned range (0 to ...)** |
| -------------- |:----------------:|:-----------------------------:|
| char           |        1         |              255              |
| short          |        2         |            65,535             |
| int, long      |        4         |         4,294,967,295         |
| long long      |        8         |      approx. 1.84*10^19       |
### Overflow
- Occurs when the result of an operation is too large to fit in the provided space
- In many languages (including C++), overflow is undetected.
	- Responsibility of the programmer to check for and/or avoid overflow conditions.
	- This is especially problematic since many specifications are given using integers (infinite).
	- Potential security hazard if integer is used in pointer arithmetic or array references
- Good rule of thumb: Restrict input as soon as it enters the program.

![[Pasted image 20251001120731.png]]

## Two's Complement Numbers

**Signed Magnitude Numbers:**
*Representing negative numbers*: RESERVE THE LEFT MOST BIT
- 0 is positive
- 1 is negative
Some issues with signed magnitude numbers:
- There are two representations of zero.
	- negative zero?
	- So, we have to assign a positive number to 0, making uneven
- Logic for dealing with sign is complicated

Two's complement numbers arrange negative and positive numbers in an ordered number line:
![[Pasted image 20251001121843.png]]

**This creates new endpoints.**

For *1 byte* the endpoints are:

| **Location**           | **Two's Complement #** | **Number** |
| ---------------------- | ---------------------- | ---------- |
| bottom (most negative) | 1000 0000              | (-128)     |
| top (most positive)    | 0111 1111              | (+127)     |
In general, if a number has *b* bits the end points are:

| **Location**               | **Number**  |
| -------------------------- | ----------- |
| bottom (most negative)<br> | -(2^(b-1))  |
| top (most positive)        | 2^(b-1) - 1 |

### Positive to Negative value:
**Algorithm:**
1) Start with the positive representation.
2) Flip the bits
3) Add 1
**Example**
![[Pasted image 20251001124918.png]]

### Negative to Positive value:
**Algorithm:** SAME THING!!!!
1) Start with the positive representation.
2) Flip the bits
3) Add 1
**Example**
![[Pasted image 20251001125150.png]]

### Addition
**Algorithm:** Addition is carried out much the same way as unsigned numbers.
- No special work for negative numbers 
- Only change is for overflow detection
- The extra *n*th digit is ignored in the result but used for overflow detection (carry-out bit)
**Example**
![[Pasted image 20251001125520.png]]

### Two's Complement Overflow
**Detecting Overflow:**
- When the "carry-in" and the "carry-out" of the sign bit (left-most bit) are *different* overflow has occurred
**Examples**
![[Pasted image 20251001130701.png]]
![[Pasted image 20251001130817.png]]

